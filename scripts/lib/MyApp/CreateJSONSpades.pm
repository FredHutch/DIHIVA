package MyApp::CreateJSONSpades;
use MooseX::App::Command;
extends 'MyApp';
with 'MyApp::Role::JSON';
use Bio::SeqIO;
use namespace::autoclean;
use feature qw(say);

command_short_description
    q[Create a JSON file from all fasta files generated by Spades.];


has 'min_scaffolds' => (
    traits   => ['AppOption'],
    cmd_type => 'option',
    is       => 'rw',
    isa      => 'Int',
    required => 0,

    #    must_exist => 0,
    documentation => q[Mininum number of reads required.]
);


has 'min_length' => (
    traits   => ['AppOption'],
    cmd_type => 'option',
    is       => 'rw',
    isa      => 'Int',
    required => 0,

    #    must_exist => 0,
    documentation => q[Mininum number of reads required.]
);


sub check_contig {
    my ($self, $file) = @_;
    my $scaffold   = Bio::SeqIO->new(-file => $file, -format => "fasta");
    my $obj        = $scaffold->next_seq;
    my $seq_length = $obj->length;

    if ($seq_length > $self->min_length) {
        return (1, $obj->length);
    }
    return (0,$obj->length);
}

sub filter_samples_fasta_step_two {

    my ($self, @fasta_files,) = @_;
    my %json_hash;
    my $step = "STEP". $self->current_step;
 
    foreach my $file (@fasta_files) {

        my $sample_id;
        if ($file =~ /^.*\/(\S+)\_S\d+\_.*/) {
            $sample_id = $1;
        } else {
            die
                "Cannot parse filename and retrive sample_id and pair information: $file";
        }

        my $contigs = 0;
        my $cmd   = 'grep -P "^>\S+" ' . $file . ' | wc -l';
        $contigs = qx/$cmd/;
        chomp $contigs;

        my $foldername;
        if ($file =~ /^.*spades\/(.*)\/clean_scaffolds.*/) {
            $foldername = $1;
        }

        my $input_path = "results/STEP1/remove_contaminants_with_bbduk/$foldername";
        my @fastq_files = glob("$input_path/*fastq*");

        my $shortname;
        if ($fastq_files[0] =~ /^.*\/(.*)(_R[12]_)(.*)(\.fastq\.gz)/ ) {
            $shortname = $1 . '_' . $3;
        }

        if ($contigs >= $self->min_scaffolds) {

            my ($verification, $longest_contig_length) = $self->check_contig($file);

            if ($verification == 1) {

                $json_hash{'passed'}{$sample_id}{$shortname}{$step}{'input'}{'R1'} = $fastq_files[0];
                $json_hash{'passed'}{$sample_id}{$shortname}{$step}{'input'}{'R2'} = $fastq_files[1];
                $json_hash{'passed'}{$sample_id}{$shortname}{$step}{'output'}{'file'} = $file;
                $json_hash{'passed'}{$sample_id}{$shortname}{$step}{'output'}{'contigs'} = $contigs;
                $json_hash{'passed'}{$sample_id}{$shortname}{$step}{'classification'} = '';
                $json_hash{'passed'}{$sample_id}{$shortname}{$step}{'reason'} = '';
            } else {
                $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'input'}{'R1'} = $fastq_files[0];
                $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'input'}{'R2'} = $fastq_files[1];
                $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'output'}{'file'} = $file;
                $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'output'}{'contigs'} = $contigs;
                $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'classification'} = 'problems_in_assembly';
                $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'reason'} = 'The longest de novo assembly is too short ('.$longest_contig_length .'bp). Min: ' . $self->min_length;
            }

        } else {
            $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'input'}{'R1'}  = $fastq_files[0];
            $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'input'}{'R2'}  = $fastq_files[1];
            $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'output'}{'file'} = $file;
            $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'output'}{'contigs'} = $contigs;
            $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'classification'} = 'problems_in_assembly';
            $json_hash{'failed'}{$sample_id}{$shortname}{$step}{'reason'} = 'Not enough contigs. Min: ' . $self->min_scaffolds;
        }

    }

    $self->export_json(\%json_hash);
}

sub run {
    my ($self) = @_;
    my @fasta_files;

    # Get subdirs
    my @dirs = glob($self->input_directory . '/*');
    foreach my $dir (@dirs) {
        if (-d $dir) {
            my @aux_fasta_files = glob($dir . '/clean_scaffolds*.' . $self->file_extension);
            push @fasta_files, @aux_fasta_files if @aux_fasta_files;
        }
    }
    $self->filter_samples_fasta_step_two(@fasta_files);

}

__PACKAGE__->meta->make_immutable;
1;
