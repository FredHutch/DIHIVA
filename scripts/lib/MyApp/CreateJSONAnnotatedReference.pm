#!/usr/bin/env perl

package MyApp::CreateJSONAnnotatedReference;
use MooseX::App::Command;
extends 'MyApp';
with 'MyApp::Role::JSON';
use namespace::autoclean;
use IO::Uncompress::AnyUncompress qw(anyuncompress $AnyUncompressError);
use Data::Printer;

command_short_description
q[Create a JSON file from all consensus files generated by MIRA and annotaded as genbank format];


## Please see file perltidy.ERR
sub filter_samples_references_gb {

    my ( $self, @fasta_files ) = @_;
    my %json_hash;

    foreach my $file (@fasta_files) {

    # get sample ID from file
        my $sample_id;
        if ( $file =~ /^.*\/(\S+)\_S\d+\_.*/ ) {
           $sample_id = $1;
        }
        else {
           die "Cannot parse filename and retrive sample_id and pair information: $file";
        }

        my $reads = 0;
        my $in    = IO::Uncompress::AnyUncompress->new($file) or die "Cannot open: $AnyUncompressError\n";

        while ( my $row = <$in> ) {
           chomp $row;
           $reads++;
        }
        close($in);

        my $input_file_pv_step;
        $input_file_pv_step = $file;

        $input_file_pv_step =~ s/STEP4/STEP3/g;
        $input_file_pv_step =~ s/minimap2_final_assembly/annot/g;
        if ($input_file_pv_step =~ /^.*annot\/.*\/(.*\.gb)$/ ) {
            $input_file_pv_step =~ s/$1//g;
            $input_file_pv_step =~ s/\/$/\.fasta/g;
        }

        my $shortname;
        if ($input_file_pv_step =~ /^.*\/(.*)\.fasta/) {
            $shortname = $1;
        }

        if ( $reads >= $self->min_reads ) {
            $json_hash{'passed'}{$sample_id}{$shortname}{ 'STEP' . $self->current_step }{'input'}{$input_file_pv_step} = $reads;
            $json_hash{'passed'}{$sample_id}{$shortname}{ 'STEP' . $self->current_step }{'output'}{$file} = $reads;
        }
        else {
            $json_hash{'failed'}{$sample_id}{$shortname}{ 'STEP' . $self->current_step }{'input'}{$input_file_pv_step} = $reads;
            $json_hash{'failed'}{$sample_id}{$shortname}{ 'STEP' . $self->current_step }{'output'}{$file} = $reads;
        }

    }

    $self->export_json( \%json_hash );
}

sub run {
    my ($self) = @_;
    my @genbank_files;

    # Get subdirs
    my @dirs = glob( $self->input_directory . '/*' );
    foreach my $dir (@dirs) {
        if ( -d $dir ) {

            # consensus_dir
            ( my $basename = $dir ) =~ s/.*\/(\.*)/$1/g;
            my @aux_genbank_files = glob( $dir . '/*.' . $self->file_extension );
            push @genbank_files, @aux_genbank_files if @aux_genbank_files;
        }
    }
    $self->filter_samples_references_gb(@genbank_files);
}

__PACKAGE__->meta->make_immutable;
1;
